<style>
    *:not(b) {font-weight: normal !important;}
    table { 
        border-collapse: collapse; 
        vertical-align: top;
        text-align: left;
    }
    th{ border: solid thin; }
    tr { border: solid thin; }
    tr:nth-child(even) {
        background-color: rgba(10,10,10,.1);
        background-blend-mode: multiply;
    }
    code {
        font-family: "Red Hat Mono",monospace;
        border: 1px solid #ccc;
        background-color: #f8f8f8;
        display: block;
        padding: 0.5em;
        margin: 0.5em;
        color: #222;
        line-height: 1.3;
        overflow: auto;
    }

   

   
</style>

<body style="font-size: 18px;">
    <h1>Arrays</h1>
    In C arrays function similarly to most languages although they are stored on the stack instead of the heap. The use of Size_T type variables is recommended for 
    indexing the array as this is a type directly built for indexing arrays. C arrays do not have length attached to them, although if in the same stack
    that the array was created the user can get the total bits of the array and divide by the bits of its type. Keep in mind that will only work for arrays and not
    linked lists, and will not work if the array was passed via a parameter to the current stack. 

    <h1>Strings</h1>
    In C, like in most languages strings are char arrays, the only place where this differs greatly in C is remembering how strings are passed in memory
    and that you are passing a pointer to the array of chars and not the string value itself, given this remember to pass them as consts if you want them 
    to be imutable 

    <h1>Input</h1>
    Input in c is not too complicated. Scanf can be used to read formatted input from stdin and will return a success bool and needs to be passed a pointer to write
    the output value to.
    <h4>Buffer</h2>
    The buffer can be cleared in many ways. The one that Deb would like for Cs2060 is while(getChar()). remember to clear the buffer once you have gotten the input you wanted.
    <!--* List of ways to clear buffer --->
    <ul>
        <li> <code>while(getChar())</code>. <b>Clears Entire Buffer.</b> This will loop while there is a char left in the buffer, there by stopping when the buffer is empty.</li>
        <li> <code>while(getChar() != '\n')</code> <b>Clears Buffer till next newline.</b> This will loop while the current char in the buffer is not a new line, thereby clearing the entire buffer upto and including the next newline.</li>
        <li> <code>int fflush(File*stream); </code> This is the prototype of the flush method, it can be used on any steam (buffers are a stream), don't use this without knowing what you are doing. DO NOT USE IN DEB's CLASS.</li>
    </ul>
    
    <h1>Types and bools</h1>
    In c bools are not immediately imported, they need to be included with <code>#include &lt;stdbool&gt;;</code> then the bool type will exist.
    <br>
    I bring this up to segway into a bigger point about C. Given its nature and ability to be very small and run on micro controllers, 
    you have to import just about everything you would want to use. It has a ton of features built into it, but to use them you need to include them.


    <h1>Test 2 Notes</h1>

    <h2>Files</h2>
    <img src="https://github.com/mattieFM/techdocs/blob/main/static/ctest1.png?raw=true">

    <ol>
        <li><b>Make a file ptr</b><br> 
            <code>FILE * filePtr = fopen ("./path", "mode")</code> 
            <table class="table table-bordered">
                <tbody><tr>
                <th style="text-align:center;">Sr.No.</th>
                <th style="text-align:center;">Mode &amp; Description</th>
                </tr>
                <tr>
                <td class="ts">1</td>
                <td><p><b>r</b></p>
                <p>Opens an existing text file for reading purpose.</p></td>
                </tr>
                <tr>
                <td class="ts">2</td>
                <td><p><b>w</b></p>
                <p>Opens a text file for writing. If it does not exist, then a new file is created. Here your program will start writing content from the beginning of the file.</p></td>
                </tr>
                <tr>
                <td class="ts">3</td>
                <td><p><b>a</b></p>
                <p>Opens a text file for writing in appending mode. If it does not exist, then a new file is created. Here your program will start appending content in the existing file content.</p></td>
                </tr>
                <tr>
                <td class="ts">4</td>
                <td><p><b>r+</b></p>
                <p>Opens a text file for both reading and writing.</p></td>
                </tr>
                <tr>
                <td class="ts">5</td>
                <td><p><b>w+</b></p>
                <p>Opens a text file for both reading and writing. It first truncates the file to zero length if it exists, otherwise creates a file if it does not exist.</p></td>
                </tr>
                <tr>
                <td class="ts">6</td>
                <td><p><b>a+</b></p>
                <p>Opens a text file for both reading and writing. It creates the file if it does not exist. The reading will start from the beginning but writing can only be appended.</p></td>
                </tr>
                </tbody></table>
            If no connection is established null is returned<br>
            if a connection is established the pointer to file struct is returned. <br>
        </li>

        <li>
            <b>check end of file marker</b>
            <p>The below code will check if the current char the filePtr points to in the file is the eof marker.</p>
            <code>feof(filePtr)</code>
            
        </li>
        <li>

        </li>
    </ol>
    <h3>file docs</h3>
    <iframe src="https://pubs.opengroup.org/onlinepubs/7908799/xsh/stdio.h.html" width="100%" height="400%"></iframe>





</body>
